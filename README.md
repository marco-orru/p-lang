# P-Lang

> Part of a University project for the class _Formal Languages and Compilers_ (**[LFT](https://laurea.informatica.unito.it/do/corsi.pl/Show?_id=tzye)**, *Linguaggi Formali e Traduttori*, UNITO Informatica).
---
This repository contains the implementation of a compiler for a very simple programming language, called ***P***, which works on integers and compiles to Java Bytecode.

The programming language supports I/O of integer numbers (which can be stored in variables) from the user, basic mathematical operations (addition, difference, multiplication, division), and selection and iteration statements. 

The compiler is made of three components:
+ A **lexer**, which tokenize the input file into tokens.
+ A **parser**, which parses the tokenized input file into an abstract syntax tree.
+ A **compiler**, which translates the AST into Java Bytecode.

To run generated Java Bytecode on the JVM, it has to be assembled using a separate tool, such as [Jasmin](https://github.com/davidar/jasmin).

## Lexer

The purpose of the lexer is reading source code text to produce a sequence of tokens (or _tokenizing_ it).
A token is a simple lexical unit, like a number, an identifier, a relational operator, a keyword or a symbol.

Tokens are represented by the `Token` class. Each token has a kind, which identifies its purpose into the language.
Token kinds are enlisted into the `TokenKind` enum.
Two special kinds of tokens are `IdentifierToken` and `NumberToken` instances. The former represents an **identifier**,
which embeds a lexeme that describes its name, while the latter represents an **integer number**, which embeds its value.

The language keywords are the following: `assign`, `to`, `if`, `else`, `end`, `while`, `print`, `read`.

The language operators and punctuators are the following: `||`, `&&`, `!`, `(`, `)`, `{`, `}`, `+`, `-`, `*`, `/`, `;`, `,`.

The special token of type `END_OF_FILE` marks the end of the source code file and shall be present exactly once, only at the end of it.

### Identifiers
Identifiers are non-empty sequences of characters which can contain ASCII letters, ASCII digits and the _underscore_ character `'_'`.
Furthermore, an identifier cannot start with a digit, and should contain at least a character different from `'_'`.

Identifiers have an arbitrary length of at least one, and are stored using Java's `String` type.

### Numbers
Numbers are sequences of ASCII digits, without any prefix, suffix or separators that make-up an integer number: thus, they are treated as integers.
Their size is 32-bit and are stored using Java's `int` type.

### Comments
Comments are pieces of text or code that are completely ignored by the lexer (and consequently by the further components of the compiler).
The language supports both end-of-line and block comments.

End-of-line comments are introduced by the character sequence `//` and are interrupted by a new-line character or by the end of the file.

Block comments are enclosed between `/*` and `*/`. An unterminated block comment makes the compiler to raise an error.

### Keywords

Keywords are special words that are reserved by the language and shall not be used as identifiers. Doing so will cause the 
compiler to raise an exception. The meaning and purpose of each keyword is discussed in the following sections.

### Operators and punctuators

Operators or punctuators are sequences (possibly composed of just one character) that are used to separate other
tokens, or to perform certain operations over numbers.

Operators can be categorized as _arithmetic operators_ (such as `+`, `-`, `*` and `/`), _relational operators_ (such as
`==`, `<>`, `<`, `>`, `<=` and `>=`), and _logical operators_ (such as `!`, `&&` and `||`).
Operator precedence is determined only by the order in which they appear in an expression.
The meaning and structure of each operator is discussed in the following sections.

## Parser

The purpose of the parser is building an Abstract Syntax Tree (or _AST_) from the sequence of tokens generated by the lexer.
The AST of the program defines its entire structure without ambiguity.

The compiler implements a top-down recursive descent parser, which is efficient and works well with the grammar of the language,
as it's in LL(1) form. 

The grammar which defines the language is the following (where `$` means _epsilon_):

```
<prog> ::= <statlist> END_OF_FILE

<statlist> ::= <stat> <statlistex>

<statlistex> ::= SEMICOLON <stat> <statlistex> | $

<stat> ::= KWD_ASSIGN <expr> KWD_TO <idlist>
        |  KWD_PRINT LEFT_PARENTHESIS <exprlist> RIGHT_PARENTHESIS
        |  KWD_READ LEFT_PARENTHESIS <idlist> RIGHT_PARENTHESIS
        |  KWD_WHILE LEFT_PARENTHESIS <bexpr> RIGHT_PARENTHESIS <stat>
        |  KWD_IF LEFT_PARENTHESIS <bexpr> RIGHT_PARENTHESIS <stat> <ifex>
        |  LEFT_BRACE <statlist> RIGHT_BRACE

<ifex> ::= KWD_END | KWD_ELSE <stat> KWD_END

<idlist> ::= IDENTIFIER <idlistex>

<idlistex> ::= COMMA IDENTIFIER <idlistex> | $

<boolexpr> ::= LOGICAL_AND <boolexpr> <boolexpr>
            |  LOGICAL_OR <boolexpr> <boolexpr>
            |  LOGICAL_NOT <boolexpr>
            |  EQUALITY <expr> <expr>
            |  INEQUALITY <expr> <expr>
            |  LESS_THAN <expr> <expr>
            |  GREATER_THAN <expr> <expr>
            |  LESS_THAN_EQUAL <expr> <expr>
            |  GREATER_THAN_EQUAL <expr> <expr>

<expr> ::= PLUS LEFT_PARENTHESIS <exprlist> RIGHT_PARENTHESIS
        |  MINUS <expr> <expr>
        |  ASTERISK LEFT_PARENTHESIS <exprlist> RIGHT_PARENTHESIS
        |  SLASH <expr> <expr>
        |  NUMBER
        |  IDENTIFIER

<exprlist> ::= <expr> <exprlistex>

<exprlistex> ::= COMMA <expr> <exprlistex> | $
```

Please note that expressions (both boolean and standard expressions) are written in prefix form, where the operator is before the operands and not between then
(as with infix form).

The result of the parser is an `AstNode`, which is the root of the program tree.

## Compiler

The purposing of the compiler is walking through the abstract syntax tree and translating each node into one or more instructions
written in Java Bytecode, that can be assembled and interpreted by the JVM. In particular, the language uses a subset of
the JVM instruction set to working only on integer numbers.

The compiler accepts an input file and produces an output file with the Java Bytecode corresponding to the P source code
provided in the input file.

### Statements
The following statements are available:
+ `assign <expr> to <idlist>`: Assigns the value of the provided expression to every identifier provided in the identifier list.
+ `print ( <exprlist> )`: Prints on standard output the value of each expression included in the expression list.
+ `read ( <idlist> )`: Asks the user for input of $n$ integer numbers (where $n$ is the length of the identifier list), each of which is assigned to the corresponding identifier provided in the identifier list.
+ `while ( <boolexpr> ) <stat>`: Executes the provided statement until the condition specified as a boolean expression evaluates to `0` (false).
+ `if ( <boolexpr> ) <stat> end`: Branches the execution flow, executing the provided statement if the boolean expression evaluates to `1` (true).
+ `if ( <boolexpr> ) <stat_1> else <stat_2> end`: Branches the execution flow, executing the first statement if the boolean expression evaluates to `1`, or the second statement if it evaluates to `0`.
+ `{ <statlist> }`: Groups a sequence of statements, allowing other statements such as _while_ and _if_ to execute more than one instruction when branching.

Please note that each statement must be followed by a semicolon (`;`) if it appears inside a statement list; otherwise,
the semicolon shall be omitted. The last statement of the source code must not be followed by a semicolon.

### Expressions
Evaluating an expression produces always an integer result. Those integers can be treated as boolean values, where `1` is _true_ and `0` is _false_.

The following expressions are available:
+ `+ ( <exprlist> )`: Sums the results of the expressions in the provided expression list.
+ `- <expr_1> <expr_2>`: Subtracts the result of the second expression from the result of the first expression.
+ `* ( <exprlist> )`: Multiplies the results of the expressions in the provided expression list.
+ `/ <expr_1> <expr_2>`: Divides the result of the first expression by the result of the second expression.
+ `NUMBER`: The expression is the value of the provided numerical constant.
+ `IDENTIFIER`: The expression is the value of the content of the provided named variable.

The following boolean expressions are available:
+ `&& <boolexpr> <boolexpr>`: Evaluates to _true_ if both the first and the second provided boolean expressions evaluate to _true_; otherwise, it evaluates to _false_.
+ `|| <boolexpr> <boolexpr>`: Evaluates to _true_ if at least one of the provided boolean expressions evaluates to _true_; otherwise, it evaluates to _false_.
+ `! <boolexpr>`: Evaluates to _true_ if the provided boolean expression evaluates to _false_; otherwise, it evaluates to _false_.
+ `@RELOP <expr_1> <expr_2>`: Evaluates to _true_ if the relational operator (`@RELOP`) applied to the provided expressions evaluates to `true`; otherwise, it evaluates to `false`.

As mentioned before, expressions are in prefix form, and does not have any rule that specifies their precedence other than the order in which they appear.
